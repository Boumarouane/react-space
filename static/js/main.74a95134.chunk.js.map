{"version":3,"sources":["components/img/earth.jpg","components/img/moon.png","components/img/fair_clouds_4k.png","components/img/nebulia.jpg","components/img/smoke.png","components/img/galaxy2.jpg","components/World.js","components/Stars.js","components/Cloud.js","components/CloudRot.js","components/Nebulia.js","components/Controls.js","components/Light.js","App.js","serviceWorker.js","index.js"],"names":["module","exports","World","props","mesh","useRef","cloudsRot","earth","useMemo","THREE","load","earthImg","moon","moonImg","cloud","cloudImg","useFrame","current","rotation","y","ref","scale","attach","args","map","fog","transparent","opacity","position","Stars","count","positions","i","theta","Math","PI","random","phi","acos","x","cos","sin","z","push","Float32Array","attachObject","length","array","itemSize","size","sizeAttenuation","color","Cloud","anneau","gaz","side","CloudRot","group","nodesCubes","Array","el","key","Nebulia","nebu","nebulia","nebuliaImg","extend","OrbitControls","Controls","controls","useThree","camera","gl","update","domElement","enableDamping","dampingFactor","rotateSpeed","Light","intensity","distance","App","stars","starsImg","onCreated","scene","gammaInput","toneMapping","setClearColor","background","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.74a95134.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/earth.7cddb76f.jpg\";","module.exports = __webpack_public_path__ + \"static/media/moon.37071536.png\";","module.exports = __webpack_public_path__ + \"static/media/fair_clouds_4k.52539824.png\";","module.exports = __webpack_public_path__ + \"static/media/nebulia.6e900d48.jpg\";","module.exports = __webpack_public_path__ + \"static/media/smoke.a7987bab.png\";","module.exports = __webpack_public_path__ + \"static/media/galaxy2.2fe8f886.jpg\";","import * as THREE from 'three';\nimport React, {useRef, useMemo} from 'react';\nimport {useFrame} from 'react-three-fiber';\nimport earthImg from './img/earth.jpg';\nimport moonImg from './img/moon.png';\nimport cloudImg from './img/fair_clouds_4k.png';\n\nconst World = (props) =>{\n\n    const mesh = useRef();\n    const cloudsRot = useRef();\n\n    const earth = useMemo(() => new THREE.TextureLoader().load(earthImg), [earthImg]);\n    const moon = useMemo(() => new THREE.TextureLoader().load(moonImg), [moonImg]);\n    const cloud = useMemo(() => new THREE.TextureLoader().load(cloudImg), [cloudImg]);\n\n    // const [earth, moon] = useLoader(new THREE.TextureLoader, [earthImg, moonImg]);\n\n    useFrame(() => {\n        mesh.current.rotation.y += 0.001;\n        cloudsRot.current.rotation.y += 0.001;\n    });\n\n    return(\n        <group ref={mesh} scale={[1, 1, 1]} {...props}>\n            <mesh ref={mesh}>\n                <sphereBufferGeometry attach='geometry' args={[2, 32, 32]}/>\n                <meshStandardMaterial attach='material' map={earth}  \n                fog={false}\n                />\n            </mesh>\n            <mesh ref={cloudsRot}>\n                <sphereBufferGeometry attach='geometry' args={[2.05, 32, 32]}/>\n                <meshBasicMaterial attach='material' map={cloud}  \n                fog={false}\n                transparent={true}\n                opacity={0.2}\n                />\n            </mesh>\n            <mesh ref={mesh} position={[20, 0, 0]}>\n                <sphereBufferGeometry attach='geometry' args={[0.75, 32, 32]}/>\n                <meshBasicMaterial attach='material' map={moon} fog={false}/>\n            </mesh>\n        </group>\n    );\n}\n\nexport default World;","import React, {useRef, useMemo} from 'react';\nimport {useFrame} from 'react-three-fiber';\n\nconst Stars = ({ count = 2000 }) =>{\n\n    const mesh = useRef();\n\n    const positions = useMemo(() => {\n    let positions = []\n    for (let i = 0; i < count; i++) {\n        const r = 400\n        const theta = 2 * Math.PI * Math.random()\n        const phi = Math.acos(2 * Math.random() - 1)\n        const x = r * Math.cos(theta) * Math.sin(phi) + (-200 + Math.random() * 400)\n        const y = r * Math.sin(theta) * Math.sin(phi) + (-200 + Math.random() * 400)\n        const z = r * Math.cos(phi) + (-100 + Math.random() * 200)\n        positions.push(x)\n        positions.push(y)\n        positions.push(z)\n    }\n    return new Float32Array(positions)\n    }, [count])\n    \n    useFrame(() => {\n        mesh.current.rotation.y += 0.0001;\n    });\n\n    return(\n        <group>\n            <points ref={mesh}>\n                <bufferGeometry attach=\"geometry\">\n                    <bufferAttribute attachObject={['attributes', 'position']} count={positions.length / 3} array={positions} itemSize={3} />\n                </bufferGeometry>\n                <pointsMaterial attach=\"material\" size={0.5} sizeAttenuation color=\"white\" fog={false} />\n            </points>\n        </group>\n    );\n}\n\nexport default Stars;","import React, {useRef, useMemo} from 'react';\nimport {useFrame} from 'react-three-fiber';\nimport gaz from \"./img/smoke.png\";\nimport { random } from \"lodash\";\nimport * as THREE from 'three';\n\n\nconst Cloud = () => {\n\n    const mesh = useRef();\n    const anneau = useMemo(() => new THREE.TextureLoader().load(gaz), [gaz]);\n\n    const position = useMemo(() => {\n        return [random(-22, 22, true), 0, random(-25, 25, true)];\n    }, []);\n\n    useFrame(() =>{\n        mesh.current.rotation.z -= 0.001;\n        mesh.current.rotation.y -= 0.001;\n    });\n\n    return (\n        <mesh ref={mesh}  position={position} rotation={[0, 0, Math.random()* 2 *Math.PI]}>\n            <planeBufferGeometry attach='geometry' args={[9, 6]} />\n            <meshLambertMaterial attach='material' map={anneau} side={THREE.DoubleSide} transparent opacity={[0.5]}/>\n        </mesh>\n    );\n}\n\nexport default Cloud;","import React, { useRef } from \"react\";\nimport { map } from \"lodash\";\nimport Cloud from \"./Cloud\";\n\nconst CloudRot =  () => {\nconst group = useRef();\n\nconst nodesCubes = map(new Array(280), (el, i) => {\n    return <Cloud key={i} />;\n});\n\nreturn <mesh ref={group}> {nodesCubes} </mesh>;\n};\n\nexport default CloudRot;","import * as THREE from 'three';\nimport React, {useRef, useMemo} from 'react';\nimport {useFrame} from 'react-three-fiber';\nimport nebuliaImg from './img/nebulia.jpg';\nimport CloudRot from './CloudRot';\n\nconst Nebulia = (props) =>{\n\n    const nebu = useRef();\n\n    const nebulia = useMemo(() => new THREE.TextureLoader().load(nebuliaImg), [nebuliaImg]);\n\n    useFrame(() => {\n        nebu.current.rotation.y += 0.001;\n    });\n\n    return(\n        <group ref={nebu} scale={[1, 1, 1]} {...props}>\n            <CloudRot/>\n            <mesh >\n                <sphereBufferGeometry attach='geometry' args={[10, 32, 32]}/>\n                <meshBasicMaterial attach='material' map={nebulia} fog={false}/>\n            </mesh>\n        </group>\n    );\n}\n\nexport default Nebulia;","import React, {  useRef } from \"react\"\nimport { extend, useFrame, useThree } from \"react-three-fiber\"\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\"\n\nextend({ OrbitControls })\n\n\nfunction Controls() {\n    const controls = useRef()\n    const { camera, gl } = useThree()\n    useFrame(() => controls.current.update())\n    return <orbitControls ref={controls} args={[camera, gl.domElement]} enableDamping dampingFactor={0.9} rotateSpeed={0.1} />\n  }\n\n  export default Controls;\n","import React from 'react';\n\nconst Light = (color) => {\n    color = '';\n    return (\n    <mesh>\n        <ambientLight intensity={0.1} color={color}/>\n        <pointLight position={[-150, 40, -165]} distance={1000} intensity={4} color={0xd8547e} />\n    </mesh>\n    );\n}\n\nexport default Light;","import * as THREE from 'three';\nimport React, { useMemo } from 'react';\nimport { Canvas } from 'react-three-fiber';\nimport World from './components/World';\nimport Stars from './components/Stars';\nimport Nebulia from './components/Nebulia';\nimport Controls from './components/Controls';\nimport Light from './components/Light';\nimport starsImg from './components/img/galaxy2.jpg';\n\n\nfunction App() {\n\n  const stars = useMemo(() => new THREE.TextureLoader().load(starsImg), [starsImg]);\n\n  return (\n    <Canvas onCreated={({ gl, scene}) => {\n      gl.gammaInput = true\n      gl.toneMapping = THREE.Uncharted2ToneMapping\n      gl.setClearColor(new THREE.Color('#020207'))\n      scene.background = stars;\n    }}\n    >\n      <Stars/>\n      <Controls/>\n      <World position={[0,-1,-5]} />\n      <Nebulia position={[-150, 40, -190]} rotation={[0.4, 0, 0]}/>\n      <Light color={0x111111}/>\n    </Canvas>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}